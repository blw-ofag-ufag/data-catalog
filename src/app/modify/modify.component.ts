import {Component, OnDestroy, OnInit} from '@angular/core';
import {CommonModule} from '@angular/common';
import {FormArray, FormBuilder, FormControl, FormGroup, ReactiveFormsModule, Validators} from '@angular/forms';
import {ActivatedRoute, Router, RouterModule} from '@angular/router';
import {Observable, Subject, takeUntil} from 'rxjs';
import {TranslatePipe, TranslateService} from '@ngx-translate/core';
import {ObAlertModule, ObButtonDirective, ObIconModule, ObNotificationModule, ObNotificationService} from '@oblique/oblique';
import {MatFormFieldModule} from '@angular/material/form-field';
import {MatInputModule} from '@angular/material/input';
import {MatDatepickerModule} from '@angular/material/datepicker';
import {MatNativeDateModule} from '@angular/material/core';
import {MatCheckboxModule} from '@angular/material/checkbox';
import {MatStepperModule} from '@angular/material/stepper';
import {MatButtonModule} from '@angular/material/button';
import {GitHubAuthService} from '../services/auth/github-auth.service';
import {RepositoryCredentialsService} from '../services/auth/repository-credentials.service';
import {MultiDatasetService} from '../services/api/multi-dataset-service.service';
import {I14YThemeService} from '../services/api/i14y-theme.service';
import {PublisherService} from '../services/api/publisher.service';
import {DatasetSubmitComponent} from './submit/dataset-submit.component';
import {MultilingualTextFieldComponent} from './form/components/multilingual-text-field/multilingual-text-field.component';
import {EnumSelectFieldComponent} from './form/components/enum-select-field/enum-select-field.component';
import {ThemeSelectFieldComponent} from './form/components/theme-select-field/theme-select-field.component';
import {KeywordArrayFieldComponent} from './form/components/keyword-array-field/keyword-array-field.component';
import {AffiliatedPersonsFieldComponent} from './form/components/affiliated-persons-field/affiliated-persons-field.component';
import {DistributionFieldComponent} from './form/components/distribution-field/distribution-field.component';
import {ValidationAlertComponent} from './components/validation-alert/validation-alert.component';
import {
	AccessRights,
	AccrualPeriocicites,
	CategorizationsDSG,
	ClassificationLevels,
	DataTypes,
	DatasetAvailabilities,
	DatasetThemes,
	Publishers,
	Statuses
} from '../models/schemas/dataset';
import {DatasetMetadataService} from '../services/metadata/dataset-metadata.service';
import {ValidationSchemaService, ValidationSchemaType} from '../services/validation/validation-schema.service';
import {ValidationGroup} from './components/validation-alert/validation-alert.component';
import {environment} from '../../environments/environment';
import {MatIconModule} from '@angular/material/icon';

@Component({
	selector: 'modify',
	standalone: true,
	imports: [
		CommonModule,
		ReactiveFormsModule,
		RouterModule,
		TranslatePipe,
		ObAlertModule,
		ObButtonDirective,
		ObNotificationModule,
		ObIconModule,
		MatFormFieldModule,
		MatInputModule,
		MatDatepickerModule,
		MatNativeDateModule,
		MatCheckboxModule,
		MatStepperModule,
		MatButtonModule,
		DatasetSubmitComponent,
		MultilingualTextFieldComponent,
		EnumSelectFieldComponent,
		ThemeSelectFieldComponent,
		KeywordArrayFieldComponent,
		AffiliatedPersonsFieldComponent,
		DistributionFieldComponent,
		ValidationAlertComponent,
		MatIconModule
	],
	templateUrl: './modify.component.html',
	styleUrl: './modify.component.scss'
})
export class ModifyComponent implements OnInit, OnDestroy {
	datasetForm: FormGroup;
	isEditMode = false;
	datasetId: string | null = null;
	isLoading = false;
	showSubmitSection = false;
	invalidFields: string[] = [];
	isLinear = false;
	submitAttempted = false;

	// Validation groups
	activeValidationSchemas: Set<ValidationSchemaType> = new Set(['base']);
	validationErrors: Map<ValidationSchemaType, string[]> = new Map();

	// Store original dataset for reset functionality in edit mode
	private originalDataset: any = null;

	// Fields that are auto-generated and should be excluded from validation
	private readonly autoGeneratedFields = ['dct:identifier'];

	// Enum options for dropdowns
	readonly publishers = Publishers;
	readonly accessRights = AccessRights;
	readonly statuses = Statuses;
	readonly classificationLevels = ClassificationLevels;
	readonly personalDataCategories = CategorizationsDSG;
	readonly availabilities = DatasetAvailabilities;
	readonly themes = DatasetThemes;
	readonly accrualPeriocicites = AccrualPeriocicites;
	readonly dataTypes = DataTypes;

	private readonly destroy$ = new Subject<void>();

	constructor(
		private readonly fb: FormBuilder,
		private readonly route: ActivatedRoute,
		private readonly router: Router,
		private readonly githubAuthService: GitHubAuthService,
		private readonly repositoryCredentialsService: RepositoryCredentialsService,
		private readonly datasetService: MultiDatasetService,
		private readonly i14yThemeService: I14YThemeService,
		private readonly publisherService: PublisherService,
		private readonly translateService: TranslateService,
		private readonly notificationService: ObNotificationService,
		private readonly metadataService: DatasetMetadataService,
		private readonly validationSchemaService: ValidationSchemaService
	) {
		this.datasetForm = this.createForm();
	}

	ngOnInit(): void {
		// Load I14Y themes
		this.i14yThemeService.loadThemes().pipe(takeUntil(this.destroy$)).subscribe();

		// Initialize form with metadata
		this.metadataService
			.getMetadata()
			.pipe(takeUntil(this.destroy$))
			.subscribe(metadata => {
				if (metadata && this.datasetForm) {
					this.buildFormFromMetadata(this.datasetForm, metadata);
				}
			});

		// Check if we're in edit mode - check both route params and query params
		this.route.paramMap.pipe(takeUntil(this.destroy$)).subscribe(params => {
			const routeDatasetId = params.get('id');

			// Also check query params for dataset ID
			this.route.queryParams.pipe(takeUntil(this.destroy$)).subscribe(queryParams => {
				// Priority: route param first, then query param
				this.datasetId = routeDatasetId || queryParams['dataset'];
				this.isEditMode = !!this.datasetId;
				this.initializeForm();
			});
		});

		// Track form changes and update tab state
		this.datasetForm.statusChanges.pipe(takeUntil(this.destroy$)).subscribe(() => {
			this.updateTabUnsavedState();
		});
	}

	ngOnDestroy(): void {
		this.destroy$.next();
		this.destroy$.complete();
	}

	private createForm(): FormGroup {
		const formGroup = this.fb.group({});

		// Subscribe to metadata to build form dynamically
		this.metadataService
			.getMetadata()
			.pipe(takeUntil(this.destroy$))
			.subscribe(metadata => {
				if (metadata) {
					this.buildFormFromMetadata(formGroup, metadata);
				}
			});

		// Fallback form creation if metadata is not available immediately
		return this.createFallbackForm();
	}

	private createFallbackForm(): FormGroup {
		// Create a minimal form structure that will be replaced when metadata loads
		return this.fb.group({
			'dct:identifier': [''],
			'dct:title': [null],
			'dct:description': [null]
		});
	}

	private buildFormFromMetadata(formGroup: FormGroup, metadata: any): void {
		// Clear existing controls
		Object.keys(formGroup.controls).forEach(key => {
			formGroup.removeControl(key);
		});

		// Build controls from metadata
		metadata.fields.forEach((fieldMetadata: any, key: string) => {
			const control = this.createControlForField(key, fieldMetadata);
			formGroup.addControl(key, control);
		});

		// Replace the current form with the new one
		this.datasetForm = formGroup;
	}

	private createControlForField(key: string, fieldMetadata: any): FormControl | FormGroup | FormArray {
		const validators = fieldMetadata.validators || [];
		const defaultValue = this.getDefaultValueForField(key, fieldMetadata);

		// Handle special cases
		switch (key) {
			case 'dcat:contactPoint':
				return this.fb.group({
					'schema:name': ['', this.metadataService.getFieldValidators('schema:name')],
					'schema:email': ['', this.metadataService.getFieldValidators('schema:email')]
				});

			case 'dct:temporal':
				return this.fb.group({
					'dcat:start_date': [null],
					'dcat:end_date': [null]
				});

			case 'bv:externalCatalogs':
				return this.fb.array([]);

			case 'dcat:distribution':
				return new FormControl(null);

			default:
				return new FormControl(defaultValue, validators);
		}
	}

	private getDefaultValueForField(key: string, fieldMetadata: any): any {
		// Set appropriate default values based on field type
		switch (fieldMetadata.type) {
			case 'boolean':
				return false;
			case 'array':
				return null;
			case 'number':
				return null;
			case 'date':
				return null;
			default:
				return fieldMetadata.enum ? '' : null;
		}
	}

	private initializeForm(): void {
		if (this.isEditMode && this.datasetId) {
			// First, ensure data is loaded if needed
			this.datasetService.datasets$.pipe(takeUntil(this.destroy$)).subscribe(datasets => {
				if (datasets && datasets.length > 0) {
					const foundDataset = datasets.find(d => d['dct:identifier'] === this.datasetId);
					if (foundDataset) {
						this.populateForm(foundDataset);
					}
				} else {
					// If no datasets loaded yet, trigger loading
					this.datasetService.loadIndex();
				}
			});

			// Also subscribe to the selected dataset from the service
			this.datasetService.selectedDataset$.pipe(takeUntil(this.destroy$)).subscribe(dataset => {
				if (dataset && dataset['dct:identifier'] === this.datasetId) {
					this.populateForm(dataset);
				}
			});
		}
	}

	private populateForm(dataset: any): void {
		// Store original dataset for reset functionality
		this.originalDataset = {...dataset};

		// Populate the form with dataset values
		const patchData: any = {};

		// Only patch values for controls that exist in the form
		Object.keys(this.datasetForm.controls).forEach(key => {
			if (dataset.hasOwnProperty(key)) {
				patchData[key] = dataset[key];
			}
		});

		this.datasetForm.patchValue(patchData);
	}

	onCancel(): void {
		// Check if form has been modified
		if (this.datasetForm.dirty) {
			const message = this.translateService.instant('modify.auth.form.confirmation.unsavedChanges');
			if (confirm(message)) {
				this.closeCurrentTab();
			}
		} else {
			this.closeCurrentTab();
		}
	}

	private closeCurrentTab(): void {
		// Navigate back to the index page
		this.router.navigate(['/']);
	}

	private updateTabUnsavedState(): void {
		// Tab functionality removed - this method is now a no-op
		// Originally tracked unsaved changes in tab state
	}

	onSubmit(): void {
		this.submitAttempted = true;

		// Update validation errors for all active schemas
		this.updateValidationErrors();

		// Capture form validity at the exact moment of submission
		const isFormValid = this.datasetForm.valid;

		if (isFormValid) {
			this.isLoading = true;
			// Simulate processing time
			setTimeout(() => {
				this.isLoading = false;
				this.showSubmitSection = true;
				// Show success notification
				this.notificationService.success({
					title: 'Form Validation Complete',
					message: 'Dataset form is valid and ready for submission to GitHub'
				});
			}, 1000);
		} else {
			this.markFormGroupTouched(this.datasetForm);
			this.collectInvalidFields();

			// Show error notification
			this.notificationService.warning({
				title: 'Form Validation Failed',
				message: `Please fix ${this.invalidFields.length} required fields to continue`
			});

			// Scroll to first error
			this.scrollToFirstError();
		}
	}


	onFormReset(): void {
		this.showSubmitSection = false;
		this.submitAttempted = false;

		if (this.isEditMode && this.originalDataset) {
			// For edit mode: restore original dataset state
			this.populateForm(this.originalDataset);
			// Mark form as pristine and untouched to reflect "no changes"
			this.resetFormState();
		} else {
			// For create mode: clear the form
			this.datasetForm.reset();
			// Reset external catalogs FormArray
			const externalCatalogsArray = this.datasetForm.get('bv:externalCatalogs') as FormArray;
			if (externalCatalogsArray) {
				externalCatalogsArray.clear();
			}
		}
	}

	private resetFormState(): void {
		// Mark the form and all its controls as pristine and untouched
		this.datasetForm.markAsPristine();
		this.datasetForm.markAsUntouched();

		Object.keys(this.datasetForm.controls).forEach(key => {
			const control = this.datasetForm.get(key);
			control?.markAsPristine();
			control?.markAsUntouched();

			if (control instanceof FormGroup) {
				this.resetFormGroupState(control);
			} else if (control instanceof FormArray) {
				control.markAsPristine();
				control.markAsUntouched();
				control.controls.forEach(arrayControl => {
					arrayControl.markAsPristine();
					arrayControl.markAsUntouched();
					if (arrayControl instanceof FormGroup) {
						this.resetFormGroupState(arrayControl);
					}
				});
			}
		});
	}

	private resetFormGroupState(formGroup: FormGroup): void {
		formGroup.markAsPristine();
		formGroup.markAsUntouched();
		Object.keys(formGroup.controls).forEach(key => {
			const control = formGroup.get(key);
			control?.markAsPristine();
			control?.markAsUntouched();
		});
	}

	private markFormGroupTouched(formGroup: FormGroup): void {
		Object.keys(formGroup.controls).forEach(key => {
			const control = formGroup.get(key);
			control?.markAsTouched();
			if (control instanceof FormGroup) {
				this.markFormGroupTouched(control);
			} else if (control instanceof FormArray) {
				control.markAsTouched();
				control.controls.forEach(arrayControl => {
					arrayControl.markAsTouched();
					if (arrayControl instanceof FormGroup) {
						this.markFormGroupTouched(arrayControl);
					}
				});
			}
		});
	}

	get externalCatalogsArray(): FormArray {
		return this.datasetForm.get('bv:externalCatalogs') as FormArray;
	}

	onExternalCatalogChange(catalogValue: string, isChecked: boolean): void {
		const formArray = this.externalCatalogsArray;

		if (isChecked) {
			// Add the catalog to the array if it's not already there
			if (!formArray.value.includes(catalogValue)) {
				formArray.push(new FormControl(catalogValue));
			}
		} else {
			// Remove the catalog from the array
			const index = formArray.value.indexOf(catalogValue);
			if (index >= 0) {
				formArray.removeAt(index);
			}
		}

		// Handle validation schema changes
		this.handleValidationSchemaChanges(catalogValue, isChecked);
	}

	private handleValidationSchemaChanges(catalogValue: string, isChecked: boolean): void {
		const schemaMap: Record<string, ValidationSchemaType> = {
			I14Y: 'i14y',
			'opendata.swiss': 'ods'
		};

		const schemaType = schemaMap[catalogValue];
		if (!schemaType) return;

		if (isChecked) {
			this.activeValidationSchemas.add(schemaType);
			this.applySchemaValidation(schemaType);
		} else {
			this.activeValidationSchemas.delete(schemaType);
			this.removeSchemaValidation(schemaType);
		}

		// Update validation errors
		this.updateValidationErrors();
	}

	private applySchemaValidation(schemaType: ValidationSchemaType): void {
		const schema = this.validationSchemaService.getSchema(schemaType);
		if (!schema) return;

		// Apply validators to form fields
		Object.keys(schema.fields).forEach(fieldKey => {
			const control = this.datasetForm.get(fieldKey);
			if (control) {
				const validators = this.validationSchemaService.getCombinedValidators(fieldKey, Array.from(this.activeValidationSchemas));
				control.setValidators(validators);
				control.updateValueAndValidity();
			}
		});
	}

	private removeSchemaValidation(schemaType: ValidationSchemaType): void {
		const schema = this.validationSchemaService.getSchema(schemaType);
		if (!schema) return;

		// Reapply only remaining schema validators
		Object.keys(schema.fields).forEach(fieldKey => {
			const control = this.datasetForm.get(fieldKey);
			if (control) {
				const validators = this.validationSchemaService.getCombinedValidators(fieldKey, Array.from(this.activeValidationSchemas));
				control.setValidators(validators);
				control.updateValueAndValidity();
			}
		});
	}

	private updateValidationErrors(): void {
		this.validationErrors.clear();

		Array.from(this.activeValidationSchemas).forEach(schemaType => {
			const errors = this.validationSchemaService.getFilteredSchemaValidationErrors(
				schemaType,
				this.datasetForm.value
			);
			this.validationErrors.set(schemaType, errors);
		});
	}

	// Getter methods for template
	get baseValidationErrors(): string[] {
		return this.validationErrors.get('base') || [];
	}

	get i14yValidationErrors(): string[] {
		return this.validationErrors.get('i14y') || [];
	}

	get odsValidationErrors(): string[] {
		return this.validationErrors.get('ods') || [];
	}

	// Get validation groups for template
	get activeValidationGroups(): ValidationGroup[] {
		const groups: ValidationGroup[] = [];

		Array.from(this.activeValidationSchemas).forEach(schemaType => {
			const schema = this.validationSchemaService.getSchema(schemaType);
			const errors = this.validationErrors.get(schemaType) || [];

			if (schema) {
				groups.push({
					name: schema.name,
					color: schema.color,
					alertType: schema.alertType,
					errors,
					icon: this.getSchemaIcon(schemaType)
				});
			}
		});

		return groups;
	}

	private getSchemaIcon(schemaType: ValidationSchemaType): string {
		const icons: Record<ValidationSchemaType, string> = {
			base: 'warning',
			i14y: 'public',
			ods: 'open_in_new'
		};
		return icons[schemaType] || 'info';
	}

	isExternalCatalogSelected(catalogValue: string): boolean {
		return this.externalCatalogsArray.value.includes(catalogValue);
	}

	private collectInvalidFields(): void {
		this.invalidFields = [];
		const labelMap: {[key: string]: string} = {
			'dct:title': this.translateService.instant('labels.dct:title'),
			'dct:description': this.translateService.instant('labels.dct:description'),
			'dct:accessRights': this.translateService.instant('labels.dct:accessRights'),
			'dct:publisher': this.translateService.instant('labels.dct:publisher'),
			'dcat:contactPoint.schema:name': this.translateService.instant('modify.auth.form.contactName'),
			'dcat:contactPoint.schema:email': this.translateService.instant('modify.auth.form.contactEmail'),
			'adms:status': this.translateService.instant('labels.adms:status'),
			'bv:classification': this.translateService.instant('labels.bv:classification'),
			'bv:personalData': this.translateService.instant('labels.bv:personalData')
		};

		Object.keys(this.datasetForm.controls).forEach(key => {
			// Skip auto-generated fields
			if (this.autoGeneratedFields.includes(key)) {
				return;
			}

			const control = this.datasetForm.get(key);
			if (control?.invalid) {
				if (control instanceof FormGroup) {
					// Handle nested form groups (like contactPoint)
					Object.keys(control.controls).forEach(nestedKey => {
						const fullNestedKey = `${key}.${nestedKey}`;
						if (this.autoGeneratedFields.includes(fullNestedKey)) {
							return;
						}

						const nestedControl = control.get(nestedKey);
						if (nestedControl?.invalid) {
							this.invalidFields.push(labelMap[fullNestedKey] || fullNestedKey);
						}
					});
				} else {
					this.invalidFields.push(labelMap[key] || key);
				}
			}
		});
	}

	private scrollToFirstError(): void {
		setTimeout(() => {
			const firstErrorElement = document.querySelector('.ng-invalid:not(form):not(fieldset)');
			if (firstErrorElement) {
				firstErrorElement.scrollIntoView({behavior: 'smooth', block: 'center'});
			}
		}, 100);
	}

	getSelectedRepositoryDisplay(): string {
		// In debug mode, show debug info
		if (environment.debugMode) {
			return `${environment.mockRepository} (ðŸ› ï¸ Debug Mode)`;
		}

		const selectedRepo = this.repositoryCredentialsService.getSelectedRepository();
		if (selectedRepo) {
			const publisher = this.publisherService.getPublishers().find(p => p.githubRepo === selectedRepo);
			return publisher ? `${publisher.shortId} (${selectedRepo})` : selectedRepo;
		}
		return 'blw-ofag-ufag/metadata'; // Default fallback
	}

	isDebugMode(): boolean {
		return environment.debugMode;
	}

	// Step validation methods - now dynamic based on metadata
	isStepValid(stepIndex: number): boolean {
		const metadata = this.metadataService.getMetadataValue();
		if (!metadata) return true;

		const step = metadata.steps[stepIndex];
		if (!step) return true;

		// Check if all required fields in this step are valid
		return step.fields.every(fieldKey => {
			// Skip auto-generated fields
			if (this.autoGeneratedFields.includes(fieldKey)) {
				return true;
			}

			// Check if field is required
			const fieldMetadata = metadata.fields.get(fieldKey);
			if (!fieldMetadata?.required) {
				return true; // Optional fields don't affect step validity
			}

			// Check if the control is valid
			const control = this.datasetForm.get(fieldKey);
			return control?.valid ?? true;
		});
	}

	// Helper methods for template access
	getStepFields(stepId: number): Observable<any[]> {
		return this.metadataService.getStepFields(stepId);
	}

	isFieldRequired(fieldKey: string): boolean {
		// Exclude auto-generated fields from validation requirements
		if (this.autoGeneratedFields.includes(fieldKey)) {
			return false;
		}

		const metadata = this.metadataService.getMetadataValue();
		if (!metadata) return false;

		const fieldMetadata = metadata.fields.get(fieldKey);
		return fieldMetadata?.required === true;
	}

	isFieldRecommended(fieldKey: string): boolean {
		const metadata = this.metadataService.getMetadataValue();
		if (!metadata) return false;

		const fieldMetadata = metadata.fields.get(fieldKey);
		return fieldMetadata?.recommended === true;
	}

	getSteps(): Observable<any[]> {
		return this.metadataService.getSteps();
	}
}
