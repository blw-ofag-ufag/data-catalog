"use strict";(self.webpackChunkDigiAgriFoodDB=self.webpackChunkDigiAgriFoodDB||[]).push([[446],{2280:(Z,P,m)=>{m.d(P,{A:()=>w});var X=m(5267);const w=function J(K){return(0,X.A)(K,4)}},6446:(Z,P,m)=>{m.r(P),m.d(P,{render:()=>re});var X=m(467),N=m(7447),w=(m(1924),m(9639)),K=m(8828),t=(m(1403),m(5011),m(3721)),Q=m(315),S=m(5113),z=m(2280),F=m(6327);function h(n){var r={options:{directed:n.isDirected(),multigraph:n.isMultigraph(),compound:n.isCompound()},nodes:$(n),edges:L(n)};return S.A(n.graph())||(r.value=z.A(n.graph())),r}function $(n){return F.A(n.nodes(),function(r){var e=n.node(r),o=n.parent(r),i={v:r};return S.A(e)||(i.value=e),S.A(o)||(i.parent=o),i})}function L(n){return F.A(n.edges(),function(r){var e=n.edge(r),o={v:r.v,w:r.w};return S.A(r.name)||(o.name=r.name),S.A(e)||(o.value=e),o})}m(5687);var G=m(8802),l=new Map,p=new Map,k=new Map,I=(0,t.K2)(()=>{p.clear(),k.clear(),l.clear()},"clear"),O=(0,t.K2)((n,r)=>{const e=p.get(r)||[];return t.Rm.trace("In isDescendant",r," ",n," = ",e.includes(n)),e.includes(n)},"isDescendant"),q=(0,t.K2)((n,r)=>{const e=p.get(r)||[];return t.Rm.info("Descendants of ",r," is ",e),t.Rm.info("Edge is ",n),n.v!==r&&n.w!==r&&(e?e.includes(n.v)||O(n.v,r)||O(n.w,r)||e.includes(n.w):(t.Rm.debug("Tilt, ",r,",not in descendants"),!1))},"edgeInCluster"),M=(0,t.K2)((n,r,e,o)=>{t.Rm.warn("Copying children of ",n,"root",o,"data",r.node(n),o);const i=r.children(n)||[];n!==o&&i.push(n),t.Rm.warn("Copying (nodes) clusterId",n,"nodes",i),i.forEach(c=>{if(r.children(c).length>0)M(c,r,e,o);else{const a=r.node(c);t.Rm.info("cp ",c," to ",o," with parent ",n),e.setNode(c,a),o!==r.parent(c)&&(t.Rm.warn("Setting parent",c,r.parent(c)),e.setParent(c,r.parent(c))),n!==o&&c!==n?(t.Rm.debug("Setting parent",c,n),e.setParent(c,n)):(t.Rm.info("In copy ",n,"root",o,"data",r.node(n),o),t.Rm.debug("Not Setting parent for node=",c,"cluster!==rootId",n!==o,"node!==clusterId",c!==n));const u=r.edges(c);t.Rm.debug("Copying Edges",u),u.forEach(d=>{t.Rm.info("Edge",d);const g=r.edge(d.v,d.w,d.name);t.Rm.info("Edge data",g,o);try{q(d,o)?(t.Rm.info("Copying as ",d.v,d.w,g,d.name),e.setEdge(d.v,d.w,g,d.name),t.Rm.info("newGraph edges ",e.edges(),e.edge(e.edges()[0]))):t.Rm.info("Skipping copy of edge ",d.v,"--\x3e",d.w," rootId: ",o," clusterId:",n)}catch(E){t.Rm.error(E)}})}t.Rm.debug("Removing node",c),r.removeNode(c)})},"copy"),U=(0,t.K2)((n,r)=>{const e=r.children(n);let o=[...e];for(const i of e)k.set(i,n),o=[...o,...U(i,r)];return o},"extractDescendants"),ee=(0,t.K2)((n,r,e)=>{const o=n.edges().filter(d=>d.v===r||d.w===r),i=n.edges().filter(d=>d.v===e||d.w===e),c=o.map(d=>({v:d.v===r?e:d.v,w:d.w===r?r:d.w})),a=i.map(d=>({v:d.v,w:d.w}));return c.filter(d=>a.some(g=>d.v===g.v&&d.w===g.w))},"findCommonEdges"),b=(0,t.K2)((n,r,e)=>{const o=r.children(n);if(t.Rm.trace("Searching children of id ",n,o),o.length<1)return n;let i;for(const c of o){const a=b(c,r,e),u=ee(r,e,a);if(a){if(!(u.length>0))return a;i=a}}return i},"findNonClusterChild"),Y=(0,t.K2)(n=>l.has(n)&&l.get(n).externalConnections&&l.has(n)?l.get(n).id:n,"getAnchorId"),ne=(0,t.K2)((n,r)=>{if(!n||r>10)t.Rm.debug("Opting out, no graph ");else{t.Rm.debug("Opting in, graph "),n.nodes().forEach(function(e){n.children(e).length>0&&(t.Rm.warn("Cluster identified",e," Replacement id in edges: ",b(e,n,e)),p.set(e,U(e,n)),l.set(e,{id:b(e,n,e),clusterData:n.node(e)}))}),n.nodes().forEach(function(e){const o=n.children(e),i=n.edges();o.length>0?(t.Rm.debug("Cluster identified",e,p),i.forEach(c=>{O(c.v,e)^O(c.w,e)&&(t.Rm.warn("Edge: ",c," leaves cluster ",e),t.Rm.warn("Descendants of XXX ",e,": ",p.get(e)),l.get(e).externalConnections=!0)})):t.Rm.debug("Not a cluster ",e,p)});for(let e of l.keys()){const o=l.get(e).id,i=n.parent(o);i!==e&&l.has(i)&&!l.get(i).externalConnections&&(l.get(e).id=i)}n.edges().forEach(function(e){const o=n.edge(e);t.Rm.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),t.Rm.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n.edge(e)));let i=e.v,c=e.w;if(t.Rm.warn("Fix XXX",l,"ids:",e.v,e.w,"Translating: ",l.get(e.v)," --- ",l.get(e.w)),l.get(e.v)||l.get(e.w)){if(t.Rm.warn("Fixing and trying - removing XXX",e.v,e.w,e.name),i=Y(e.v),c=Y(e.w),n.removeEdge(e.v,e.w,e.name),i!==e.v){const a=n.parent(i);l.get(a).externalConnections=!0,o.fromCluster=e.v}if(c!==e.w){const a=n.parent(c);l.get(a).externalConnections=!0,o.toCluster=e.w}t.Rm.warn("Fix Replacing with XXX",i,c,e.name),n.setEdge(i,c,o,e.name)}}),t.Rm.warn("Adjusted Graph",h(n)),j(n,0),t.Rm.trace(l)}},"adjustClustersAndEdges"),j=(0,t.K2)((n,r)=>{if(t.Rm.warn("extractor - ",r,h(n),n.children("D")),r>10)return void t.Rm.error("Bailing out");let e=n.nodes(),o=!1;for(const i of e){const c=n.children(i);o=o||c.length>0}if(o){t.Rm.debug("Nodes = ",e,r);for(const i of e)if(t.Rm.debug("Extracting node",i,l,l.has(i)&&!l.get(i).externalConnections,!n.parent(i),n.node(i),n.children("D")," Depth ",r),l.has(i))if(!l.get(i).externalConnections&&n.children(i)&&n.children(i).length>0){t.Rm.warn("Cluster without external connections, without a parent and with children",i,r);let a="TB"===n.graph().rankdir?"LR":"TB";l.get(i)?.clusterData?.dir&&(a=l.get(i).clusterData.dir,t.Rm.warn("Fixing dir",l.get(i).clusterData.dir,a));const u=new G.T({multigraph:!0,compound:!0}).setGraph({rankdir:a,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});t.Rm.warn("Old graph before copy",h(n)),M(i,n,u,i),n.setNode(i,{clusterNode:!0,id:i,clusterData:l.get(i).clusterData,label:l.get(i).label,graph:u}),t.Rm.warn("New graph after copy node: (",i,")",h(u)),t.Rm.debug("Old graph after copy",h(n))}else t.Rm.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!l.get(i).externalConnections," no parent: ",!n.parent(i)," children ",n.children(i)&&n.children(i).length>0,n.children("D"),r),t.Rm.debug(l);else t.Rm.debug("Not a cluster",i,r);e=n.nodes(),t.Rm.warn("New list of nodes",e);for(const i of e){const c=n.node(i);t.Rm.warn(" Now next level",i,c),c?.clusterNode&&j(c.graph,r+1)}}else t.Rm.debug("Done, no node has children",n.nodes())},"extractor"),H=(0,t.K2)((n,r)=>{if(0===r.length)return[];let e=Object.assign([],r);return r.forEach(o=>{const i=n.children(o),c=H(n,i);e=[...e,...c]}),e},"sorter"),te=(0,t.K2)(n=>H(n,n.children()),"sortNodesByHierarchy"),W=(0,t.K2)(function(){var n=(0,X.A)(function*(r,e,o,i,c,a){t.Rm.warn("Graph in recursive render:XAX",h(e),c);const u=e.graph().rankdir;t.Rm.trace("Dir in recursive render - dir:",u);const d=r.insert("g").attr("class","root");e.nodes()?t.Rm.info("Recursive render XXX",e.nodes()):t.Rm.info("No nodes found for",e),e.edges().length>0&&t.Rm.info("Recursive edges",e.edge(e.edges()[0]));const g=d.insert("g").attr("class","clusters"),E=d.insert("g").attr("class","edgePaths"),C=d.insert("g").attr("class","edgeLabels"),y=d.insert("g").attr("class","nodes");yield Promise.all(e.nodes().map(function(){var v=(0,X.A)(function*(f){const s=e.node(f);if(void 0!==c){const R=JSON.parse(JSON.stringify(c.clusterData));t.Rm.trace("Setting data for parent cluster XXX\n Node.id = ",f,"\n data=",R.height,"\nParent cluster",c.height),e.setNode(c.id,R),e.parent(f)||(t.Rm.trace("Setting parent",f,c.id),e.setParent(f,c.id,R))}if(t.Rm.info("(Insert) Node XXX"+f+": "+JSON.stringify(e.node(f))),s?.clusterNode){t.Rm.info("Cluster identified XBX",f,s.width,e.node(f));const{ranksep:R,nodesep:A}=e.graph();s.graph.setGraph({...s.graph.graph(),ranksep:R+25,nodesep:A});const D=yield W(y,s.graph,o,i,e.node(f),a),V=D.elem;(0,w.lC)(s,V),s.diff=D.diff||0,t.Rm.info("New compound node after recursive render XAX",f,"width",s.width,"height",s.height),(0,w.U7)(V,s)}else e.children(f).length>0?(t.Rm.trace("Cluster - the non recursive path XBX",f,s.id,s,s.width,"Graph:",e),t.Rm.trace(b(s.id,e)),l.set(s.id,{id:b(s.id,e),node:s})):(t.Rm.trace("Node - the non recursive path XAX",f,y,e.node(f),u),yield(0,w.on)(y,e.node(f),{config:a,dir:u}))});return function(f){return v.apply(this,arguments)}}())),yield(0,t.K2)((0,X.A)(function*(){const v=e.edges().map(function(){var f=(0,X.A)(function*(s){const R=e.edge(s.v,s.w,s.name);t.Rm.info("Edge "+s.v+" -> "+s.w+": "+JSON.stringify(s)),t.Rm.info("Edge "+s.v+" -> "+s.w+": ",s," ",JSON.stringify(e.edge(s))),t.Rm.info("Fix",l,"ids:",s.v,s.w,"Translating: ",l.get(s.v),l.get(s.w)),yield(0,N.jP)(C,R)});return function(s){return f.apply(this,arguments)}}());yield Promise.all(v)}),"processEdges")(),t.Rm.info("Graph before layout:",JSON.stringify(h(e))),t.Rm.info("############################################# XXX"),t.Rm.info("###                Layout                 ### XXX"),t.Rm.info("############################################# XXX"),(0,Q.Zp)(e),t.Rm.info("Graph after layout:",JSON.stringify(h(e)));let T=0,{subGraphTitleTotalMargin:B}=(0,K.O)(a);return yield Promise.all(te(e).map(function(){var v=(0,X.A)(function*(f){const s=e.node(f);if(t.Rm.info("Position XBX => "+f+": ("+s.x,","+s.y,") width: ",s.width," height: ",s.height),s?.clusterNode)s.y+=B,t.Rm.info("A tainted cluster node XBX1",f,s.id,s.width,s.height,s.x,s.y,e.parent(f)),l.get(s.id).node=s,(0,w.U_)(s);else if(e.children(f).length>0){t.Rm.info("A pure cluster node XBX1",f,s.id,s.x,s.y,s.width,s.height,e.parent(f)),s.height+=B,e.node(s.parentId);const R=s?.padding/2||0,A=s?.labelBBox?.height||0;t.Rm.debug("OffsetY",A-R||0,"labelHeight",A,"halfPadding",R),yield(0,w.U)(g,s),l.get(s.id).node=s}else{const R=e.node(s.parentId);s.y+=B/2,t.Rm.info("A regular node XBX1 - using the padding",s.id,"parent",s.parentId,s.width,s.height,s.x,s.y,"offsetY",s.offsetY,"parent",R,R?.offsetY,s),(0,w.U_)(s)}});return function(f){return v.apply(this,arguments)}}())),e.edges().forEach(function(v){const f=e.edge(v);t.Rm.info("Edge "+v.v+" -> "+v.w+": "+JSON.stringify(f),f),f.points.forEach(D=>D.y+=B/2);const s=e.node(v.v);var R=e.node(v.w);const A=(0,N.Jo)(E,f,l,o,s,R,i);(0,N.T_)(f,A)}),e.nodes().forEach(function(v){const f=e.node(v);t.Rm.info(v,f.type,f.diff),f.isGroup&&(T=f.diff)}),t.Rm.warn("Returning from recursive render XAX",d,T),{elem:d,diff:T}});return function(r,e,o,i,c,a){return n.apply(this,arguments)}}(),"recursiveRender"),re=(0,t.K2)(function(){var n=(0,X.A)(function*(r,e){const o=new G.T({multigraph:!0,compound:!0}).setGraph({rankdir:r.direction,nodesep:r.config?.nodeSpacing||r.config?.flowchart?.nodeSpacing||r.nodeSpacing,ranksep:r.config?.rankSpacing||r.config?.flowchart?.rankSpacing||r.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),i=e.select("g");(0,N.g0)(i,r.markers,r.type,r.diagramId),(0,w.gh)(),(0,N.IU)(),(0,w.IU)(),I(),r.nodes.forEach(a=>{o.setNode(a.id,{...a}),a.parentId&&o.setParent(a.id,a.parentId)}),t.Rm.debug("Edges:",r.edges),r.edges.forEach(a=>{if(a.start===a.end){const u=a.start,d=u+"---"+u+"---1",g=u+"---"+u+"---2",E=o.node(u);o.setNode(d,{domId:d,id:d,parentId:E.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),o.setParent(d,E.parentId),o.setNode(g,{domId:g,id:g,parentId:E.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),o.setParent(g,E.parentId);const C=structuredClone(a),y=structuredClone(a),x=structuredClone(a);C.label="",C.arrowTypeEnd="none",C.id=u+"-cyclic-special-1",y.arrowTypeStart="none",y.arrowTypeEnd="none",y.id=u+"-cyclic-special-mid",x.label="",E.isGroup&&(C.fromCluster=u,x.toCluster=u),x.id=u+"-cyclic-special-2",x.arrowTypeStart="none",o.setEdge(u,d,C,u+"-cyclic-special-0"),o.setEdge(d,g,y,u+"-cyclic-special-1"),o.setEdge(g,u,x,u+"-cyc<lic-special-2")}else o.setEdge(a.start,a.end,{...a},a.id)}),t.Rm.warn("Graph at first:",JSON.stringify(h(o))),ne(o),t.Rm.warn("Graph after XAX:",JSON.stringify(h(o)));const c=(0,t.D7)();yield W(i,o,r.type,r.diagramId,void 0,c)});return function(r,e){return n.apply(this,arguments)}}(),"render")}}]);